{% extends "base.html" %}
{% block title %}Herald - Game{% endblock %}

{% block head %}
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<script src="/static/js/store/gameStore.js"></script>
<style>
/* Custom styles for game board */
.unit-card { transition: all 0.2s ease; }
.unit-card.activated { opacity: 0.6; }
.unit-card.shaken { border-color: #fbbf24 !important; }
.unit-card.destroyed { opacity: 0.4; filter: grayscale(1); }
.unit-group { margin-bottom: 0.5rem; }
.unit-group .unit-card:not(:first-child) { margin-top: -0.25rem; }
.unit-group .bg-base-200 { border-left: 2px solid hsl(var(--p)); }

.health-bar { transition: width 0.3s ease; }
.objective-marker { transition: all 0.2s ease; cursor: pointer; }
.objective-marker:hover { transform: scale(1.1); }

.player-column { min-height: 200px; }

/* Mobile-first responsive styles */
@media (max-width: 768px) {
    .game-layout {
        flex-direction: column !important;
    }
    
    .player-column {
        border-right: none !important;
        border-left: none !important;
        border-bottom: 1px solid hsl(var(--b3));
        max-height: 40vh;
        overflow-y: auto;
    }
    
    .center-panel {
        width: 100% !important;
        order: -1; /* Move center panel to top on mobile */
        max-height: none;
        flex: 0 0 auto !important;
    }
    
    .center-panel .objectives-section {
        padding: 0.5rem !important;
    }
    
    .center-panel .game-log {
        max-height: 150px;
    }
    
    .objective-marker {
        width: 2.5rem !important;
        height: 2.5rem !important;
        font-size: 0.875rem !important;
    }
    
    .unit-card .card-body {
        padding: 0.5rem !important;
    }
    
    /* Make buttons more touch-friendly */
    .btn-xs {
        min-height: 2rem;
        padding-left: 0.75rem;
        padding-right: 0.75rem;
    }
    
    /* Stack unit controls vertically */
    .unit-controls {
        flex-direction: column;
    }
    
    /* Header adjustments */
    .navbar {
        padding: 0.5rem;
    }
    
    .navbar .flex-none {
        flex-wrap: wrap;
        gap: 0.25rem !important;
    }
}

/* Tablet adjustments */
@media (min-width: 769px) and (max-width: 1024px) {
    .center-panel {
        width: 16rem !important;
    }
}

/* Touch-friendly controls */
@media (pointer: coarse) {
    .btn {
        min-height: 2.5rem;
    }
    
    .btn-xs {
        min-height: 2rem;
    }
    
    .btn-circle {
        width: 2rem;
        height: 2rem;
    }
}
</style>
{% endblock %}

{% block content %}
<div id="game-board" class="min-h-screen bg-base-300">
    
    <!-- Loading State -->
    <div v-if="isLoading" class="flex items-center justify-center min-h-screen">
        <span class="loading loading-spinner loading-lg"></span>
    </div>
    
    <!-- Error State -->
    <div v-else-if="error" class="flex items-center justify-center min-h-screen">
        <div class="alert alert-error max-w-md">
            <span>[[ error ]]</span>
            <a :href="`${getBasePath()}/`" class="btn btn-sm">Back to Lobby</a>
        </div>
    </div>
    
    <!-- No Game State (shouldn't happen, but safety) -->
    <div v-else-if="!game" class="flex items-center justify-center min-h-screen">
        <div class="text-center">
            <span class="loading loading-spinner loading-lg"></span>
            <p class="mt-4 text-base-content/70">Loading game...</p>
        </div>
    </div>
    
    <!-- Game Board -->
    <div v-else class="flex flex-col h-screen">
        
        <!-- Top Bar -->
        <header class="navbar bg-base-100 shadow-lg px-4">
            <div class="flex-1">
                <span class="text-lg font-bold">[[ game.name ]]</span>
                <span class="badge badge-outline ml-2">[[ game.code ]]</span>
                <span class="badge ml-2" :class="statusBadgeClass">[[ game.status ]]</span>
            </div>
            <div class="flex-none gap-2">
                <div class="badge badge-lg badge-primary">Round [[ game.current_round ]] / [[ game.max_rounds ]]</div>
                <div v-if="isConnected" class="badge badge-success gap-1">
                    <span class="w-2 h-2 rounded-full bg-success animate-pulse"></span>
                    Live
                </div>
                <div v-else class="badge badge-error gap-1">Disconnected</div>
            </div>
        </header>
        
        <!-- Main Content -->
        <main class="flex-1 overflow-hidden flex game-layout">
            
            <!-- Left Column (local player if present) -->
            <div class="player-column flex-1 p-4 overflow-y-auto border-r border-base-200 md:border-r" :class="{ 'opacity-50 pointer-events-none': isExpired }">
                <div v-if="leftPlayer" class="mb-4">
                    <!-- Player Header -->
                    <div class="flex items-center gap-2 mb-2">
                        <div 
                            class="w-4 h-4 rounded-full"
                            :style="{ backgroundColor: leftPlayer.color }"
                        ></div>
                        <h2 class="text-lg font-bold">[[ leftPlayer.name ]]</h2>
                        <span v-if="!leftPlayer.is_connected" class="badge badge-warning badge-sm">Offline</span>
                        <span v-if="game.current_player_id === leftPlayer.id" class="badge badge-info badge-sm">Active</span>
                    </div>
                    
                    <!-- Army Health Bar -->
                    <div class="mb-4">
                        <div class="flex justify-between text-sm mb-1">
                            <span>Army Health</span>
                            <span>[[ Math.round(getArmyHealth(leftPlayer.id) * 100) ]]%</span>
                        </div>
                        <div class="w-full bg-base-300 rounded-full h-2">
                            <div 
                                class="health-bar h-2 rounded-full"
                                :class="getHealthBarClass(getArmyHealth(leftPlayer.id))"
                                :style="{ width: (getArmyHealth(leftPlayer.id) * 100) + '%' }"
                            ></div>
                        </div>
                        <div v-if="isMoraleThreshold(leftPlayer.id)" class="text-warning text-xs mt-1">
                            ⚠️ Morale Threshold Reached
                        </div>
                    </div>
                    
                    <!-- Units -->
                    <div class="space-y-2">
                        <unit-card 
                            v-for="unit in getPlayerUnits(leftPlayer.id)"
                            :key="unit.id"
                            :unit="unit"
                            :is-mine="leftPlayer.id === currentPlayerId"
                            @update="updateUnit"
                        ></unit-card>
                    </div>
                </div>
            </div>
            
            <!-- Center Panel (Objectives, Turn Controls, Log) -->
            <div class="center-panel w-80 bg-base-200 flex flex-col">
                
                <!-- Victory Points -->
                <div class="objectives-section p-4 border-b border-base-300">
                    <h3 class="font-bold mb-2">Victory Points</h3>
                    <div class="flex justify-around gap-2">
                        <div v-if="leftPlayer" class="flex items-center gap-1">
                            <span :style="{ color: leftPlayer.color }">[[ leftPlayer.name ]]:</span>
                            <button 
                                class="btn btn-xs btn-circle btn-ghost"
                                @click="updateVP(leftPlayer.id, -1)"
                                :disabled="isExpired || leftPlayer.victory_points <= 0"
                            >
                                -
                            </button>
                            <span class="font-bold min-w-[2rem] text-center">[[ leftPlayer.victory_points ]]</span>
                            <button 
                                class="btn btn-xs btn-circle btn-ghost"
                                @click="updateVP(leftPlayer.id, 1)"
                                :disabled="isExpired"
                            >
                                +
                            </button>
                        </div>
                        <div v-if="rightPlayer" class="flex items-center gap-1">
                            <span :style="{ color: rightPlayer.color }">[[ rightPlayer.name ]]:</span>
                            <button 
                                class="btn btn-xs btn-circle btn-ghost"
                                @click="updateVP(rightPlayer.id, -1)"
                                :disabled="isExpired || rightPlayer.victory_points <= 0"
                            >
                                -
                            </button>
                            <span class="font-bold min-w-[2rem] text-center">[[ rightPlayer.victory_points ]]</span>
                            <button 
                                class="btn btn-xs btn-circle btn-ghost"
                                @click="updateVP(rightPlayer.id, 1)"
                                :disabled="isExpired"
                            >
                                +
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Solo Mode Indicator -->
                <div v-if="game.is_solo" class="p-4 border-b border-base-300 bg-warning/10">
                    <div class="flex items-center justify-between">
                        <div class="flex items-center gap-2">
                            <span class="badge badge-warning">Solo Mode</span>
                            <span class="text-xs text-base-content/70">Controlling both armies</span>
                        </div>
                    </div>
                </div>
                
                <!-- Player Switcher (Solo Mode Only) -->
                <div v-if="game.is_solo && (game.status === 'lobby' || game.status === 'in_progress') && players.length > 1" class="p-4 border-b border-base-300">
                    <h3 class="font-bold mb-2">Control Player</h3>
                    <div class="space-y-2">
                        <button
                            v-for="player in players"
                            :key="player.id"
                            class="btn btn-sm btn-block"
                            :class="currentPlayerId === player.id ? 'btn-primary' : 'btn-outline'"
                            @click="switchPlayer(player.id)"
                            :disabled="isExpired"
                        >
                            [[ player.name ]]
                            <span v-if="currentPlayerId === player.id" class="badge badge-sm ml-2">Active</span>
                        </button>
                    </div>
                </div>
                
                <!-- Save/Load Controls (Solo Mode Only) -->
                <div v-if="game.is_solo" class="p-4 border-b border-base-300">
                    <h3 class="font-bold mb-2">Save/Load</h3>
                    <div class="space-y-2">
                        <button
                            class="btn btn-sm btn-block btn-outline"
                            @click="showSaveModal = true"
                        >
                            Save Game
                        </button>
                        <button
                            class="btn btn-sm btn-block btn-outline"
                            @click="showLoadModal = true"
                            :disabled="isExpired"
                        >
                            Load Game
                        </button>
                    </div>
                </div>
                
                <!-- Round Tracker -->
                <div class="p-4 border-b border-base-300">
                    <h3 class="font-bold mb-2">Round</h3>
                    <div class="flex items-center justify-center gap-2">
                        <button 
                            class="btn btn-xs btn-circle btn-ghost"
                            @click="updateRound(-1)"
                            :disabled="isExpired || game.current_round <= 1"
                        >
                            -
                        </button>
                        <span class="font-bold min-w-[3rem] text-center">[[ game.current_round ]]</span>
                        <button 
                            class="btn btn-xs btn-circle btn-ghost"
                            @click="updateRound(1)"
                            :disabled="isExpired"
                        >
                            +
                        </button>
                    </div>
                </div>
                
                <!-- Turn Controls -->
                <div class="p-4 border-b border-base-300" v-if="game.status === 'in_progress'">
                    <h3 class="font-bold mb-2">Turn Controls</h3>
                    <div class="space-y-2">
                        <button 
                            class="btn btn-sm btn-block"
                            :disabled="isExpired || game.current_round >= game.max_rounds"
                            @click="advanceRound"
                        >
                            End Round → Round [[ game.current_round + 1 ]]
                        </button>
                        <button 
                            v-if="game.current_round >= game.max_rounds"
                            class="btn btn-sm btn-block btn-warning"
                            @click="endGame"
                        >
                            End Game
                        </button>
                    </div>
                </div>
                
                <!-- Lobby Controls (before game starts) -->
                <div class="p-4 border-b border-base-300" v-if="game.status === 'lobby'">
                    <h3 class="font-bold mb-2">Game Setup</h3>
                    
                    <!-- Player Selector (Solo Mode Only) -->
                    <div v-if="game.is_solo && players.length > 1" class="form-control mb-2">
                        <label class="label">
                            <span class="label-text">Add Units To</span>
                        </label>
                        <select 
                            v-model="selectedPlayerForUnits"
                            class="select select-sm select-bordered w-full"
                        >
                            <option 
                                v-for="player in players"
                                :key="player.id"
                                :value="player.id"
                            >
                                [[ player.name ]]
                            </option>
                        </select>
                    </div>
                    
                    <!-- Army Import -->
                    <div class="form-control mb-2">
                        <label class="label label-text">Army Forge URL</label>
                        <input 
                            type="text" 
                            v-model="armyForgeUrl"
                            placeholder="Paste share link..."
                            class="input input-sm input-bordered"
                        />
                    </div>
                    <button 
                        class="btn btn-sm btn-block mb-2"
                        :disabled="!armyForgeUrl || isImporting"
                        :class="{ 'loading': isImporting }"
                        @click="importArmy"
                        :disabled="isExpired"
                    >
                        Import Army
                    </button>
                    
                    <div class="divider text-xs">or</div>
                    
                    <button 
                        class="btn btn-sm btn-block btn-outline mb-2"
                        @click="showManualUnitModal = true"
                        :disabled="isExpired"
                    >
                        Add Unit Manually
                    </button>
                    
                    <button 
                        v-if="currentPlayerId && getPlayerUnits(currentPlayerId).length > 0"
                        class="btn btn-sm btn-block btn-error btn-outline mb-2"
                        @click="showClearUnitsModal = true"
                        :disabled="isExpired"
                    >
                        Clear All Units
                    </button>
                    
                    <div class="divider text-xs">or</div>
                    
                    <button 
                        class="btn btn-sm btn-block btn-primary"
                        :disabled="isExpired || (!game.is_solo && players.length < 2) || !hasUnits"
                        @click="startGame"
                    >
                        Start Game
                    </button>
                    <p v-if="!game.is_solo && players.length < 2" class="text-xs text-center mt-1 text-warning">
                        Waiting for opponent...
                    </p>
                    <p v-else-if="game.is_solo && players.length === 0" class="text-xs text-center mt-1 text-warning">
                        Add at least one player with units
                    </p>
                    <p v-else-if="!hasUnits" class="text-xs text-center mt-1 text-warning">
                        <span v-if="game.is_solo">Add units to start</span>
                        <span v-else>Both players need armies</span>
                    </p>
                </div>
                
                <!-- Game Log -->
                <div class="game-log flex-1 overflow-hidden flex flex-col">
                    <div class="p-2 border-b border-base-300 flex justify-between items-center">
                        <h3 class="font-bold text-sm">Game Log</h3>
                        <button 
                            class="btn btn-xs btn-ghost"
                            @click="exportEventLog"
                            title="Export event log as markdown"
                        >
                            Export
                        </button>
                    </div>
                    <div class="flex-1 overflow-y-auto p-2 space-y-1 text-xs max-h-64 md:max-h-none">
                        <div 
                            v-for="event in events"
                            :key="event.id"
                            class="p-2 bg-base-300 rounded"
                        >
                            <div class="flex justify-between text-base-content/50">
                                <span>R[[ event.round_number ]]</span>
                                <span>[[ formatTime(event.created_at) ]]</span>
                            </div>
                            <div>[[ event.description ]]</div>
                        </div>
                        <div v-if="events.length === 0" class="text-center text-base-content/50 py-4">
                            No events yet
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Right Column (opponent if present) -->
            <div class="player-column flex-1 p-4 overflow-y-auto border-l border-base-200" :class="{ 'opacity-50 pointer-events-none': isExpired }">
                <div v-if="rightPlayer" class="mb-4">
                    <!-- Player Header -->
                    <div class="flex items-center gap-2 mb-2">
                        <div 
                            class="w-4 h-4 rounded-full"
                            :style="{ backgroundColor: rightPlayer.color }"
                        ></div>
                        <h2 class="text-lg font-bold">[[ rightPlayer.name ]]</h2>
                        <span v-if="!rightPlayer.is_connected" class="badge badge-warning badge-sm">Offline</span>
                        <span v-if="game.current_player_id === rightPlayer.id" class="badge badge-info badge-sm">Active</span>
                    </div>
                    
                    <!-- Army Health Bar -->
                    <div class="mb-4">
                        <div class="flex justify-between text-sm mb-1">
                            <span>Army Health</span>
                            <span>[[ Math.round(getArmyHealth(rightPlayer.id) * 100) ]]%</span>
                        </div>
                        <div class="w-full bg-base-300 rounded-full h-2">
                            <div 
                                class="health-bar h-2 rounded-full"
                                :class="getHealthBarClass(getArmyHealth(rightPlayer.id))"
                                :style="{ width: (getArmyHealth(rightPlayer.id) * 100) + '%' }"
                            ></div>
                        </div>
                        <div v-if="isMoraleThreshold(rightPlayer.id)" class="text-warning text-xs mt-1">
                            ⚠️ Morale Threshold Reached
                        </div>
                    </div>
                    
                    <!-- Units -->
                    <div class="space-y-2">
                        <unit-card 
                            v-for="unit in getPlayerUnits(rightPlayer.id)"
                            :key="unit.id"
                            :unit="unit"
                            :is-mine="rightPlayer.id === currentPlayerId"
                            @update="updateUnit"
                        ></unit-card>
                    </div>
                </div>
                <div v-else class="flex items-center justify-center h-full text-base-content/50">
                    Waiting for opponent to join...
                </div>
            </div>
            
        </main>
        
    </div>
    
    <!-- Player Selection / Join Modal -->
    <dialog v-if="showPlayerSelect && !currentPlayerId" :open="showPlayerSelect && !currentPlayerId" class="modal modal-open">
        <div class="modal-box space-y-3">
            <h3 class="font-bold text-lg">Join Game</h3>
            <p class="text-base-content/70">
                <span v-if="allowNewPlayer">Enter your name to join this game.</span>
                <span v-else-if="availablePlayers.length">Select a player to rejoin.</span>
                <span v-else>All player slots are currently active.</span>
            </p>
            
            <!-- Select existing player -->
            <div v-if="availablePlayers.length" class="space-y-2">
                <button 
                    v-for="player in availablePlayers" 
                    :key="player.id"
                    class="btn btn-block justify-start gap-3"
                    @click="selectPlayer(player)"
                >
                    <div 
                        class="w-6 h-6 rounded-full"
                        :style="{ backgroundColor: player.color }"
                    ></div>
                    <span>[[ player.name ]]</span>
                    <span v-if="player.is_host" class="badge badge-sm">Host</span>
                    <span v-if="!player.is_connected" class="badge badge-ghost badge-sm">Disconnected</span>
                </button>
            </div>
            
            <!-- Create new player (only when a slot is empty) -->
            <div v-else-if="allowNewPlayer" class="space-y-3">
                <div class="form-control">
                    <label class="label">
                        <span class="label-text">Name</span>
                    </label>
                    <input 
                        type="text" 
                        class="input input-bordered w-full" 
                        placeholder="Your name"
                        v-model="newPlayerName"
                    />
                </div>
                <div class="form-control">
                    <label class="label">
                        <span class="label-text">Color</span>
                    </label>
                    <input 
                        type="color" 
                        class="input input-bordered w-24 h-12 p-1" 
                        v-model="newPlayerColor"
                    />
                </div>
                <div v-if="joinError" class="alert alert-error">
                    [[ joinError ]]
                </div>
                <div class="flex gap-2">
                    <button class="btn btn-primary flex-1" @click="createNewPlayer">Join Game</button>
                    <a :href="`${getBasePath()}/`" class="btn btn-outline">Cancel</a>
                </div>
            </div>
            
            <!-- No slots available -->
            <div v-else class="space-y-3">
                <div v-if="joinError" class="alert alert-error">[[ joinError ]]</div>
                <p class="text-sm text-base-content/70">This game already has two active players.</p>
                <a :href="`${getBasePath()}/`" class="btn btn-outline btn-block">Return to Lobby</a>
            </div>
        </div>
        <div class="modal-backdrop bg-black/50"></div>
    </dialog>
    
    <!-- Manual Unit Entry Modal -->
    <dialog v-if="showManualUnitModal" :open="showManualUnitModal" class="modal modal-open">
        <div class="modal-box max-w-2xl max-h-[90vh] overflow-y-auto">
            <h3 class="font-bold text-lg mb-4">Add Unit Manually</h3>
            
            <form @submit.prevent="submitManualUnit" class="space-y-4">
                <!-- Basic Info -->
                <div class="form-control">
                    <label class="label">
                        <span class="label-text">Unit Name *</span>
                    </label>
                    <input 
                        type="text" 
                        v-model="manualUnitForm.name"
                        placeholder="e.g., Tactical Squad"
                        class="input input-bordered"
                        required
                        maxlength="100"
                    />
                </div>
                
                <div class="form-control">
                    <label class="label">
                        <span class="label-text">Custom Name (optional)</span>
                    </label>
                    <input 
                        type="text" 
                        v-model="manualUnitForm.custom_name"
                        placeholder="e.g., Alpha Squad"
                        class="input input-bordered"
                        maxlength="100"
                    />
                </div>
                
                <!-- Stats -->
                <div class="grid grid-cols-2 md:grid-cols-5 gap-2">
                    <div class="form-control">
                        <label class="label">
                            <span class="label-text">Quality *</span>
                        </label>
                        <input 
                            type="number" 
                            v-model.number="manualUnitForm.quality"
                            min="2" 
                            max="6" 
                            class="input input-bordered"
                            required
                        />
                    </div>
                    
                    <div class="form-control">
                        <label class="label">
                            <span class="label-text">Defense *</span>
                        </label>
                        <input 
                            type="number" 
                            v-model.number="manualUnitForm.defense"
                            min="2" 
                            max="6" 
                            class="input input-bordered"
                            required
                        />
                    </div>
                    
                    <div class="form-control">
                        <label class="label">
                            <span class="label-text">Size *</span>
                        </label>
                        <input 
                            type="number" 
                            v-model.number="manualUnitForm.size"
                            min="1" 
                            class="input input-bordered"
                            required
                        />
                    </div>
                    
                    <div class="form-control">
                        <label class="label">
                            <span class="label-text">Tough *</span>
                        </label>
                        <input 
                            type="number" 
                            v-model.number="manualUnitForm.tough"
                            min="1" 
                            class="input input-bordered"
                            required
                        />
                    </div>
                    
                    <div class="form-control">
                        <label class="label">
                            <span class="label-text">Cost *</span>
                        </label>
                        <input 
                            type="number" 
                            v-model.number="manualUnitForm.cost"
                            min="0" 
                            class="input input-bordered"
                            required
                        />
                    </div>
                </div>
                
                <!-- Special Flags -->
                <div class="form-control">
                    <label class="label">
                        <span class="label-text font-semibold">Special Properties</span>
                    </label>
                    <div class="space-y-2">
                        <label class="label cursor-pointer">
                            <span class="label-text">Hero</span>
                            <input 
                                type="checkbox" 
                                v-model="manualUnitForm.is_hero"
                                class="checkbox"
                            />
                        </label>
                        
                        <label class="label cursor-pointer">
                            <span class="label-text">Caster</span>
                            <input 
                                type="checkbox" 
                                v-model="manualUnitForm.is_caster"
                                class="checkbox"
                            />
                        </label>
                        <div v-if="manualUnitForm.is_caster" class="ml-6">
                            <label class="label">
                                <span class="label-text">Caster Level</span>
                            </label>
                            <input 
                                type="number" 
                                v-model.number="manualUnitForm.caster_level"
                                min="0" 
                                max="6" 
                                class="input input-bordered input-sm"
                            />
                        </div>
                        
                        <label class="label cursor-pointer">
                            <span class="label-text">Transport</span>
                            <input 
                                type="checkbox" 
                                v-model="manualUnitForm.is_transport"
                                class="checkbox"
                            />
                        </label>
                        <div v-if="manualUnitForm.is_transport" class="ml-6">
                            <label class="label">
                                <span class="label-text">Transport Capacity</span>
                            </label>
                            <input 
                                type="number" 
                                v-model.number="manualUnitForm.transport_capacity"
                                min="0" 
                                class="input input-bordered input-sm"
                            />
                        </div>
                        
                        <label class="label cursor-pointer">
                            <span class="label-text">Ambush</span>
                            <input 
                                type="checkbox" 
                                v-model="manualUnitForm.has_ambush"
                                class="checkbox"
                            />
                        </label>
                        
                        <label class="label cursor-pointer">
                            <span class="label-text">Scout</span>
                            <input 
                                type="checkbox" 
                                v-model="manualUnitForm.has_scout"
                                class="checkbox"
                            />
                        </label>
                    </div>
                </div>
                
                <!-- Attachment -->
                <div v-if="currentPlayerId && getPlayerUnits(currentPlayerId).length > 0" class="form-control">
                    <label class="label">
                        <span class="label-text">Attach to Unit (optional)</span>
                    </label>
                    <select 
                        v-model="manualUnitForm.attached_to_unit_id"
                        class="select select-bordered"
                    >
                        <option :value="null">None (independent unit)</option>
                        <option 
                            v-for="unit in getPlayerUnits(currentPlayerId)"
                            :key="unit.id"
                            :value="unit.id"
                        >
                            [[ unit.custom_name || unit.name ]]
                        </option>
                    </select>
                </div>
                
                <!-- Advanced (JSON) -->
                <div class="collapse collapse-arrow bg-base-200">
                    <input type="checkbox" />
                    <div class="collapse-title text-sm font-medium">
                        Advanced: Loadout & Rules (JSON)
                    </div>
                    <div class="collapse-content space-y-2">
                        <div class="form-control">
                            <label class="label">
                                <span class="label-text text-xs">Loadout (JSON array)</span>
                            </label>
                            <textarea 
                                v-model="manualUnitForm.loadout_json"
                                placeholder='[{"name": "Rifle", "attacks": 1}]'
                                class="textarea textarea-bordered textarea-sm font-mono text-xs"
                                rows="3"
                            ></textarea>
                        </div>
                        
                        <div class="form-control">
                            <label class="label">
                                <span class="label-text text-xs">Rules (JSON array)</span>
                            </label>
                            <textarea 
                                v-model="manualUnitForm.rules_json"
                                placeholder='[{"name": "Hero", "rating": null}]'
                                class="textarea textarea-bordered textarea-sm font-mono text-xs"
                                rows="3"
                            ></textarea>
                        </div>
                    </div>
                </div>
                
                <!-- Actions -->
                <div class="modal-action">
                    <button 
                        type="button"
                        class="btn btn-ghost"
                        @click="showManualUnitModal = false"
                    >
                        Cancel
                    </button>
                    <button 
                        type="submit"
                        class="btn btn-primary"
                        :disabled="isCreatingUnit"
                        :class="{ 'loading': isCreatingUnit }"
                    >
                        Add Unit
                    </button>
                </div>
            </form>
        </div>
        <div class="modal-backdrop bg-black/50" @click="showManualUnitModal = false"></div>
    </dialog>
    
    <!-- Clear Units Confirmation Modal -->
    <dialog v-if="showClearUnitsModal" :open="showClearUnitsModal" class="modal modal-open">
        <div class="modal-box">
            <h3 class="font-bold text-lg mb-4">Clear All Units?</h3>
            
            <div class="space-y-4">
                <div class="alert alert-warning">
                    <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                    </svg>
                    <span>Are you sure you want to clear all your units? This action cannot be undone.</span>
                </div>
                
                <div v-if="currentPlayerId" class="bg-base-200 p-4 rounded-lg">
                    <p class="text-sm">
                        <strong>This will remove:</strong><br>
                        [[ getPlayerUnits(currentPlayerId).length ]] unit(s)<br>
                        <span v-if="getPlayerUnits(currentPlayerId).length > 0">
                            [[ getPlayerUnits(currentPlayerId).reduce((sum, u) => sum + (u.cost || 0), 0) ]] points
                        </span>
                    </p>
                </div>
                
                <div class="modal-action">
                    <button 
                        type="button"
                        class="btn btn-ghost"
                        @click="showClearUnitsModal = false"
                    >
                        Cancel
                    </button>
                    <button 
                        type="button"
                        class="btn btn-error"
                        :disabled="isClearingUnits"
                        :class="{ 'loading': isClearingUnits }"
                        @click="confirmClearUnits"
                        :disabled="isExpired"
                    >
                        Clear All Units
                    </button>
                </div>
            </div>
        </div>
        <div class="modal-backdrop bg-black/50" @click="showClearUnitsModal = false"></div>
    </dialog>
    
    <!-- Expired Game Modal -->
    <dialog v-if="showExpiredModal" :open="showExpiredModal" class="modal modal-open">
        <div class="modal-box">
            <h3 class="font-bold text-lg mb-4">Game Expired</h3>
            <p class="mb-4">
                <span v-if="game?.is_solo">
                    This game has expired due to inactivity (no activity for 30 days). All game actions are disabled.
                </span>
                <span v-else>
                    This game has expired due to inactivity (no connected users for 1 hour). All game actions are disabled.
                </span>
            </p>
            <p class="text-sm text-base-content/70 mb-4">
                Event logs will remain available for 24 hours for review.
            </p>
            <div class="modal-action">
                <button 
                    type="button"
                    class="btn btn-primary"
                    @click="exportEventLog"
                >
                    Export Event Log
                </button>
                <button 
                    type="button"
                    class="btn btn-ghost"
                    @click="showExpiredModal = false"
                >
                    Close
                </button>
            </div>
        </div>
        <div class="modal-backdrop bg-black/50" @click="showExpiredModal = false"></div>
    </dialog>
    
    <!-- Save Game Modal -->
    <dialog v-if="showSaveModal" :open="showSaveModal" class="modal modal-open">
        <div class="modal-box">
            <h3 class="font-bold text-lg mb-4">Save Game</h3>
            
            <form @submit.prevent="saveGame" class="space-y-4">
                <div class="form-control">
                    <label class="label">
                        <span class="label-text">Save Name</span>
                    </label>
                    <input
                        type="text"
                        v-model="saveForm.saveName"
                        placeholder="My Save"
                        class="input input-bordered"
                        required
                    />
                </div>
                
                <div class="form-control">
                    <label class="label">
                        <span class="label-text">Description (optional)</span>
                    </label>
                    <textarea
                        v-model="saveForm.description"
                        placeholder="Round 2, turn 3..."
                        class="textarea textarea-bordered"
                        rows="3"
                    ></textarea>
                </div>
                
                <div class="modal-action">
                    <button
                        type="button"
                        class="btn btn-ghost"
                        @click="showSaveModal = false"
                    >
                        Cancel
                    </button>
                    <button
                        type="submit"
                        class="btn btn-primary"
                        :disabled="isSaving || !saveForm.saveName"
                        :class="{ 'loading': isSaving }"
                    >
                        Save
                    </button>
                </div>
            </form>
        </div>
        <div class="modal-backdrop bg-black/50" @click="showSaveModal = false"></div>
    </dialog>
    
    <!-- Load Game Modal -->
    <dialog v-if="showLoadModal" :open="showLoadModal" class="modal modal-open">
        <div class="modal-box max-w-2xl">
            <h3 class="font-bold text-lg mb-4">Load Game</h3>
            
            <div v-if="isLoadingSaves" class="text-center py-8">
                <span class="loading loading-spinner loading-lg"></span>
                <p class="mt-4">Loading saves...</p>
            </div>
            
            <div v-else-if="gameSaves.length === 0" class="text-center py-8">
                <p class="text-base-content/70">No saved games found</p>
            </div>
            
            <div v-else class="space-y-2 max-h-96 overflow-y-auto">
                <div
                    v-for="save in gameSaves"
                    :key="save.id"
                    class="card bg-base-200 p-4 cursor-pointer hover:bg-base-300 transition-colors"
                    @click="loadGame(save.id)"
                >
                    <div class="flex items-center justify-between">
                        <div>
                            <h4 class="font-bold">[[ save.save_name ]]</h4>
                            <p v-if="save.description" class="text-sm text-base-content/70 mt-1">
                                [[ save.description ]]
                            </p>
                            <p class="text-xs text-base-content/50 mt-1">
                                Saved: [[ formatDate(save.saved_at) ]]
                            </p>
                        </div>
                        <button
                            class="btn btn-sm btn-primary"
                            :disabled="isLoadingGame"
                            :class="{ 'loading': isLoadingGame }"
                            @click.stop="loadGame(save.id)"
                        >
                            Load
                        </button>
                    </div>
                </div>
            </div>
            
            <div class="modal-action mt-4">
                <button
                    type="button"
                    class="btn btn-ghost"
                    @click="showLoadModal = false"
                >
                    Close
                </button>
            </div>
        </div>
        <div class="modal-backdrop bg-black/50" @click="showLoadModal = false"></div>
    </dialog>
</div>

<!-- Unit Card Component Template -->
<template id="unit-card-template">
    <div class="unit-group">
        <div 
            class="unit-card card card-compact bg-base-100 shadow"
            :class="{
                'activated': unit.state?.activated_this_round,
                'shaken': unit.state?.is_shaken,
                'destroyed': unit.state?.deployment_status === 'destroyed',
                'border-2 border-warning': unit.state?.is_shaken,
            }"
        >
        <div class="card-body p-3">
            <!-- Header -->
            <div class="flex items-center justify-between">
                <div class="flex items-center gap-2">
                    <span class="font-bold text-sm">[[ unit.custom_name || unit.name ]]</span>
                    <span class="badge badge-sm">[[ unit.size ]]</span>
                    <span v-if="unit.is_hero" class="badge badge-sm badge-secondary">Hero</span>
                    <span v-if="unit.is_caster" class="badge badge-sm badge-accent">Caster</span>
                    <span v-if="attachedHeroes.length > 0" class="badge badge-sm badge-primary">+[[ attachedHeroes.length ]] Hero[[ attachedHeroes.length > 1 ? 'es' : '' ]]</span>
                </div>
                <span class="text-xs text-base-content/50">[[ unit.cost ]]pts</span>
            </div>
            
            <!-- Stats Row -->
            <div class="flex gap-4 text-xs">
                <span><strong>Q</strong>[[ unit.quality ]]+</span>
                <span><strong>D</strong>[[ unit.defense ]]+</span>
                <span v-if="unit.tough > 1"><strong>T</strong>[[ unit.tough ]]</span>
            </div>
            
            <!-- Status Badges -->
            <div class="flex flex-wrap gap-1" v-if="unit.state">
                <span v-if="unit.state.deployment_status === 'in_ambush'" class="badge badge-xs badge-info">Ambush</span>
                <span v-if="unit.state.deployment_status === 'embarked'" class="badge badge-xs badge-info">
                    Embarked
                    <span v-if="transportName" class="ml-1">([[ transportName ]])</span>
                </span>
                <span v-if="unit.state.is_fatigued" class="badge badge-xs badge-warning">Fatigued</span>
                <span v-if="unit.state.activated_this_round" class="badge badge-xs badge-neutral">Activated</span>
            </div>
            
            <!-- Transport Info (for transports) -->
            <div v-if="unit.is_transport" class="flex items-center gap-2 text-xs bg-base-200 rounded px-2 py-1">
                <span class="font-bold">Transport:</span>
                <span>[[ embarkedCount ]] / [[ unit.transport_capacity ]]</span>
                <span v-if="embarkedUnits.length > 0" class="text-base-content/70">
                    ([[ embarkedUnits.map(u => u.name).join(', ') ]])
                </span>
            </div>
            
            <!-- Controls (only for own units) -->
            <div v-if="isMine && unit.state" class="unit-controls flex flex-wrap gap-2 mt-2">
                
                <!-- Wounds (parent unit) -->
                <div class="flex items-center gap-1 bg-base-200 rounded px-2 py-1">
                    <span class="text-xs">Wounds:</span>
                    <button class="btn btn-xs btn-circle" @click="adjustWounds(-1)" :disabled="unit.state.wounds_taken <= 0">-</button>
                    <span class="font-mono w-8 text-center">[[ unit.state.wounds_taken ]] / [[ maxWounds ]]</span>
                    <button class="btn btn-xs btn-circle" @click="adjustWounds(1)" :disabled="unit.state.wounds_taken >= maxWounds">+</button>
                </div>
                
                <!-- Attached Hero Wounds (if any) -->
                <template v-for="hero in attachedHeroes" :key="hero.id">
                    <div v-if="hero && hero.state" class="flex items-center gap-1 bg-base-200 rounded px-2 py-1">
                        <span class="text-xs">[[ hero.custom_name || hero.name ]] W:</span>
                        <button class="btn btn-xs btn-circle" @click="adjustHeroWounds(hero, -1)" :disabled="!hero.state || hero.state.wounds_taken <= 0">-</button>
                        <span class="font-mono w-8 text-center">[[ hero.state?.wounds_taken || 0 ]] / [[ hero.size * hero.tough ]]</span>
                        <button class="btn btn-xs btn-circle" @click="adjustHeroWounds(hero, 1)" :disabled="!hero.state || hero.state.wounds_taken >= (hero.size * hero.tough)">+</button>
                    </div>
                </template>
                
                <!-- Spell Tokens (for Casters - parent unit) -->
                <div v-if="unit.is_caster" class="flex items-center gap-1 bg-base-200 rounded px-2 py-1">
                    <span class="text-xs">Tokens:</span>
                    <button class="btn btn-xs btn-circle" @click="adjustTokens(-1)" :disabled="unit.state.spell_tokens <= 0">-</button>
                    <span class="font-mono w-8 text-center">[[ unit.state.spell_tokens ]] / 6</span>
                    <button class="btn btn-xs btn-circle" @click="adjustTokens(1)" :disabled="unit.state.spell_tokens >= 6">+</button>
                </div>
                
                <!-- Attached Hero Spell Tokens (if any) -->
                <template v-for="hero in attachedHeroes" :key="`tokens-${hero.id}`">
                    <div v-if="hero && hero.is_caster && hero.state" class="flex items-center gap-1 bg-base-200 rounded px-2 py-1">
                        <span class="text-xs">[[ hero.custom_name || hero.name ]] T:</span>
                        <button class="btn btn-xs btn-circle" @click="adjustHeroTokens(hero, -1)" :disabled="!hero.state || hero.state.spell_tokens <= 0">-</button>
                        <span class="font-mono w-8 text-center">[[ hero.state?.spell_tokens || 0 ]] / 6</span>
                        <button class="btn btn-xs btn-circle" @click="adjustHeroTokens(hero, 1)" :disabled="!hero.state || hero.state.spell_tokens >= 6">+</button>
                    </div>
                </template>
                
                <!-- Limited Weapons -->
                <div v-if="limitedWeapons.length > 0" class="w-full">
                    <div class="text-xs text-base-content/70 mb-1">Limited Weapons:</div>
                    <div class="flex flex-wrap gap-1">
                        <button 
                            v-for="weapon in limitedWeapons"
                            :key="weapon.name"
                            class="btn btn-xs"
                            :class="isWeaponUsed(weapon.name) ? 'btn-disabled line-through opacity-50' : 'btn-outline btn-accent'"
                            @click="toggleLimitedWeapon(weapon.name)"
                            :disabled="isWeaponUsed(weapon.name)"
                        >
                            [[ weapon.label || weapon.name ]]
                            <span v-if="isWeaponUsed(weapon.name)" class="ml-1">✓</span>
                        </button>
                    </div>
                </div>
                
                <!-- Toggle Buttons -->
                <div class="flex gap-1 flex-wrap">
                    <button 
                        class="btn btn-xs"
                        :class="unit.state.activated_this_round ? 'btn-neutral' : 'btn-outline'"
                        @click="toggleActivated"
                        :disabled="!!unit.attached_to_unit_id"
                        :title="attachedHeroes.length > 0 ? `Activate ${unit.name} and ${attachedHeroes.length} attached hero${attachedHeroes.length > 1 ? 'es' : ''}` : (unit.attached_to_unit_id ? 'Attached heroes activate with their parent unit' : '')"
                    >
                        [[ unit.state.activated_this_round ? '✓ Activated' : (attachedHeroes.length > 0 ? `Activate (+${attachedHeroes.length})` : 'Activate') ]]
                    </button>
                    <button 
                        class="btn btn-xs"
                        :class="unit.state.is_shaken ? 'btn-warning' : 'btn-outline'"
                        @click="toggleShaken"
                        :title="attachedHeroes.length > 0 ? 'Shaken status applies to unit and attached heroes' : ''"
                    >
                        [[ unit.state.is_shaken ? '⚠ Shaken' : 'Shaken' ]]
                    </button>
                    
                    <!-- Detach button (for attached heroes) -->
                    <button 
                        v-if="unit.attached_to_unit_id"
                        class="btn btn-xs btn-outline btn-info"
                        @click="detachUnit"
                        title="Detach this hero from its parent unit"
                    >
                        Detach
                    </button>
                </div>
                
                <!-- Deploy from Ambush -->
                <button 
                    v-if="unit.state.deployment_status === 'in_ambush' && canDeploy"
                    class="btn btn-xs btn-success"
                    @click="deployUnit"
                >
                    Deploy from Ambush
                </button>
                
                <!-- Transport Controls -->
                <div v-if="availableTransports.length > 0 && unit.state.deployment_status === 'deployed' && !unit.is_transport" class="dropdown dropdown-top">
                    <label tabindex="0" class="btn btn-xs btn-outline">Embark</label>
                    <ul tabindex="0" class="dropdown-content z-10 menu p-2 shadow bg-base-100 rounded-box w-52">
                        <li v-for="transport in availableTransports" :key="transport.id">
                            <a @click="embarkUnit(transport.id)">
                                [[ transport.name ]] ([[ getTransportSpace(transport) ]] free)
                            </a>
                        </li>
                    </ul>
                </div>
                
                <!-- Disembark -->
                <button 
                    v-if="unit.state.deployment_status === 'embarked'"
                    class="btn btn-xs btn-info"
                    @click="disembarkUnit"
                >
                    Disembark
                </button>
                
                <!-- Destroy -->
                <button 
                    v-if="unit.state.deployment_status !== 'destroyed'"
                    class="btn btn-xs btn-error btn-outline"
                    @click="destroyUnit"
                >
                    Destroy
                </button>
            </div>
        </div>
        
        <!-- Attached Heroes (nested below parent unit) -->
        <div v-if="attachedHeroes && attachedHeroes.length > 0" class="ml-4 mt-0 space-y-0 border-l-2 border-primary pl-2">
            <template v-for="hero in attachedHeroes" :key="hero.id">
                <div 
                    v-if="hero"
                    class="unit-card card card-compact bg-base-200 shadow-sm -mt-1 first:mt-0"
                    :class="{
                        'activated': hero.state?.activated_this_round,
                        'shaken': hero.state?.is_shaken,
                        'destroyed': hero.state?.deployment_status === 'destroyed',
                    }"
                >
                <div class="card-body p-2">
                    <!-- Hero Header (compact) -->
                    <div class="flex items-center justify-between">
                        <div class="flex items-center gap-1">
                            <span class="text-xs font-semibold">[[ hero.custom_name || hero.name ]]</span>
                            <span class="badge badge-xs">[[ hero.size ]]</span>
                            <span v-if="hero.is_hero" class="badge badge-xs badge-secondary">Hero</span>
                            <span v-if="hero.is_caster" class="badge badge-xs badge-accent">Caster</span>
                        </div>
                        <span class="text-xs text-base-content/50">[[ hero.cost ]]pts</span>
                    </div>
                    
                    <!-- Hero Stats (compact) -->
                    <div class="flex gap-3 text-xs text-base-content/70">
                        <span><strong>Q</strong>[[ hero.quality ]]+</span>
                        <span><strong>D</strong>[[ hero.defense ]]+</span>
                        <span v-if="hero.tough > 1"><strong>T</strong>[[ hero.tough ]]</span>
                    </div>
                    
                    <!-- Hero Status Badges -->
                    <div class="flex flex-wrap gap-1 text-xs" v-if="hero && hero.state">
                        <span v-if="hero.state.deployment_status === 'in_ambush'" class="badge badge-xs badge-info">Ambush</span>
                        <span v-if="hero.state.is_fatigued" class="badge badge-xs badge-warning">Fatigued</span>
                        <span v-if="hero.state.activated_this_round" class="badge badge-xs badge-neutral">Activated</span>
                    </div>
                    
                    <!-- Hero Status (read-only, controls are on parent unit) -->
                    <div v-if="hero && hero.state" class="text-xs text-base-content/70 mt-1">
                        <span>W: [[ hero.state?.wounds_taken || 0 ]] / [[ hero.size * hero.tough ]]</span>
                        <span v-if="hero.is_caster" class="ml-2">T: [[ hero.state?.spell_tokens || 0 ]] / 6</span>
                        <span v-if="hero.state?.is_shaken" class="ml-2 text-warning">⚠ Shaken</span>
                    </div>
                </div>
                </div>
            </template>
        </div>
    </div>
</template>

<script>
document.addEventListener("DOMContentLoaded", () => {
    const { createApp, ref, computed, reactive, onMounted, onUnmounted, watch } = Vue;
    
    const GAME_CODE = "{{ game_code }}";
    
    // Unit Card Component
    const UnitCard = {
        template: '#unit-card-template',
        props: {
            unit: { type: Object, required: true },
            isMine: { type: Boolean, default: false },
        },
        emits: ['update'],
        setup(props, { emit }) {
            const store = GameStore;
            
            const maxWounds = computed(() => props.unit.size * props.unit.tough);
            
            // Find attached heroes for this unit
            const attachedHeroes = computed(() => {
                if (!store.state.units || !Array.isArray(store.state.units)) {
                    return [];
                }
                return store.state.units.filter(u => u && u.attached_to_unit_id === props.unit.id);
            });
            
            // Find parent unit if this unit is attached
            const attachedToUnitName = computed(() => {
                if (!props.unit.attached_to_unit_id) return null;
                const parentUnit = store.state.units.find(u => u.id === props.unit.attached_to_unit_id);
                return parentUnit ? (parentUnit.custom_name || parentUnit.name) : null;
            });
            
            const canDeploy = computed(() => {
                return store.state.game?.current_round >= 2;
            });
            
            // Transport-related computed properties
            const embarkedUnits = computed(() => {
                if (!props.unit.is_transport) return [];
                return store.state.units.filter(u => u.state?.transport_id === props.unit.id);
            });
            
            const embarkedCount = computed(() => {
                return embarkedUnits.value.reduce((total, u) => total + u.size, 0);
            });
            
            const transportName = computed(() => {
                if (!props.unit.state?.transport_id) return null;
                const transport = store.state.units.find(u => u.id === props.unit.state.transport_id);
                return transport?.name || null;
            });
            
            const availableTransports = computed(() => {
                // Find transports belonging to the same player with available space
                return store.state.units.filter(u => 
                    u.is_transport && 
                    u.player_id === props.unit.player_id &&
                    u.state?.deployment_status === 'deployed' &&
                    u.id !== props.unit.id &&
                    getTransportSpace(u) >= props.unit.size
                );
            });
            
            const getTransportSpace = (transport) => {
                const occupied = store.state.units
                    .filter(u => u.state?.transport_id === transport.id)
                    .reduce((total, u) => total + u.size, 0);
                return transport.transport_capacity - occupied;
            };
            
            const embarkUnit = (transportId) => {
                emit('update', props.unit.id, { 
                    deployment_status: 'embarked',
                    transport_id: transportId 
                });
            };
            
            const disembarkUnit = () => {
                emit('update', props.unit.id, { 
                    deployment_status: 'deployed',
                    transport_id: null 
                });
            };
            
            // Extract Limited weapons from loadout
            const limitedWeapons = computed(() => {
                if (!props.unit.loadout) return [];
                
                const weapons = [];
                const processLoadout = (items) => {
                    for (const item of items) {
                        // Check if this is a weapon with Limited rule
                        if (item.specialRules) {
                            const hasLimited = item.specialRules.some(
                                rule => rule.name?.toLowerCase() === 'limited'
                            );
                            if (hasLimited) {
                                weapons.push({
                                    name: item.name,
                                    label: item.label || item.name,
                                    count: item.count || 1,
                                });
                            }
                        }
                        // Check label for "Limited" text as backup
                        if (item.label && item.label.toLowerCase().includes('limited')) {
                            if (!weapons.find(w => w.name === item.name)) {
                                weapons.push({
                                    name: item.name,
                                    label: item.label || item.name,
                                    count: item.count || 1,
                                });
                            }
                        }
                        // Recurse into content if exists
                        if (item.content && Array.isArray(item.content)) {
                            processLoadout(item.content);
                        }
                    }
                };
                
                processLoadout(props.unit.loadout);
                return weapons;
            });
            
            const isWeaponUsed = (weaponName) => {
                const usedList = props.unit.state?.limited_weapons_used || [];
                return usedList.includes(weaponName);
            };
            
            const toggleLimitedWeapon = (weaponName) => {
                const currentUsed = props.unit.state?.limited_weapons_used || [];
                if (!currentUsed.includes(weaponName)) {
                    // Mark as used
                    emit('update', props.unit.id, { 
                        limited_weapons_used: [...currentUsed, weaponName] 
                    });
                }
                // Note: We don't allow un-using limited weapons (they're one-use per game)
            };
            
            const adjustWounds = (delta) => {
                const newWounds = Math.max(0, Math.min(maxWounds.value, props.unit.state.wounds_taken + delta));
                emit('update', props.unit.id, { wounds_taken: newWounds });
            };
            
            const adjustTokens = (delta) => {
                const newTokens = Math.max(0, Math.min(6, props.unit.state.spell_tokens + delta));
                emit('update', props.unit.id, { spell_tokens: newTokens });
            };
            
            const toggleActivated = () => {
                if (props.unit.attached_to_unit_id) {
                    alert(`${props.unit.custom_name || props.unit.name} is attached to another unit and cannot be activated separately. Activate the parent unit instead.`);
                    return;
                }
                emit('update', props.unit.id, { activated_this_round: !props.unit.state.activated_this_round });
            };
            
            const toggleShaken = () => {
                emit('update', props.unit.id, { is_shaken: !props.unit.state.is_shaken });
            };
            
            const deployUnit = () => {
                emit('update', props.unit.id, { deployment_status: 'deployed' });
            };
            
            const destroyUnit = () => {
                if (confirm(`Destroy ${props.unit.name}?`)) {
                    emit('update', props.unit.id, { deployment_status: 'destroyed' });
                }
            };
            
            // Helper functions for attached heroes
            const adjustHeroWounds = (hero, delta) => {
                if (!hero || !hero.state) return;
                const maxWounds = hero.size * hero.tough;
                const newWounds = Math.max(0, Math.min(maxWounds, hero.state.wounds_taken + delta));
                emit('update', hero.id, { wounds_taken: newWounds });
            };
            
            const adjustHeroTokens = (hero, delta) => {
                if (!hero || !hero.state) return;
                const newTokens = Math.max(0, Math.min(6, hero.state.spell_tokens + delta));
                emit('update', hero.id, { spell_tokens: newTokens });
            };
            
            
            const detachUnit = async () => {
                if (!confirm(`Detach ${props.unit.custom_name || props.unit.name} from its parent unit?`)) {
                    return;
                }
                
                try {
                    const code = store.state.game?.code;
                    if (!code) return;
                    
                    // Get base path from window location
                    const pathParts = window.location.pathname.split('/');
                    const basePath = pathParts.slice(0, -2).join('/') || '';
                    
                    const response = await fetch(`${basePath}/api/games/${code}/units/${props.unit.id}/detach`, {
                        method: 'PATCH',
                        headers: { 'Content-Type': 'application/json' },
                    });
                    
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.detail || 'Failed to detach unit');
                    }
                    
                    // Refresh game state
                    await store.actions.fetchGame(code);
                } catch (error) {
                    alert('Failed to detach unit: ' + error.message);
                }
            };
            
            return {
                maxWounds,
                attachedHeroes,
                attachedToUnitName,
                canDeploy,
                embarkedUnits,
                embarkedCount,
                transportName,
                availableTransports,
                getTransportSpace,
                embarkUnit,
                disembarkUnit,
                limitedWeapons,
                isWeaponUsed,
                toggleLimitedWeapon,
                adjustWounds,
                adjustTokens,
                toggleActivated,
                toggleShaken,
                deployUnit,
                destroyUnit,
                adjustHeroWounds,
                adjustHeroTokens,
                detachUnit,
            };
        },
    };
    
    // Main App
    const GameBoardApp = {
        components: { UnitCard },
        setup() {
            const store = GameStore;
            
            // Reactive refs to store state
            const game = computed(() => store.state.game);
            const players = computed(() => store.state.players);
            const units = computed(() => store.state.units);
            const objectives = computed(() => store.state.objectives);
            const events = computed(() => store.state.events);
            const isLoading = computed(() => store.state.isLoading);
            const isConnected = computed(() => store.state.isConnected);
            const error = computed(() => store.state.error);
            const currentPlayerId = computed(() => store.state.currentPlayerId);
            
            // Order players so "me" is left
            const leftPlayer = computed(() => {
                return players.value.find(p => p.id === currentPlayerId.value) || players.value[0] || null;
            });
            const rightPlayer = computed(() => {
                return players.value.find(p => p.id && leftPlayer.value && p.id !== leftPlayer.value.id) || players.value[1] || null;
            });
            
            const armyForgeUrl = ref('');
            const isImporting = ref(false);
            const showManualUnitModal = ref(false);
            const isCreatingUnit = ref(false);
            const showClearUnitsModal = ref(false);
            const isClearingUnits = ref(false);
            const showSaveModal = ref(false);
            const showLoadModal = ref(false);
            const isSaving = ref(false);
            const isLoadingGame = ref(false);
            const isLoadingSaves = ref(false);
            const gameSaves = ref([]);
            const showExpiredModal = ref(false);
            const saveForm = reactive({
                saveName: '',
                description: '',
            });
            const selectedPlayerForUnits = ref(null);
            const manualUnitForm = reactive({
                name: '',
                custom_name: '',
                quality: 4,
                defense: 4,
                size: 1,
                tough: 1,
                cost: 0,
                is_hero: false,
                is_caster: false,
                caster_level: 0,
                is_transport: false,
                transport_capacity: 0,
                has_ambush: false,
                has_scout: false,
                attached_to_unit_id: null,
                loadout_json: '',
                rules_json: '',
            });
            
            // Helper to get base path based on environment
            const getBasePath = () => {
                return (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1')
                    ? ''
                    : '/herald';
            };
            
            // Computed
            const statusBadgeClass = computed(() => {
                switch (game.value?.status) {
                    case 'lobby': return 'badge-info';
                    case 'in_progress': return 'badge-success';
                    case 'completed': return 'badge-neutral';
                    default: return '';
                }
            });
            
            const hasUnits = computed(() => {
                return players.value.every(p => 
                    units.value.some(u => u.player_id === p.id)
                );
            });
            
            const isExpired = computed(() => {
                return game.value?.status === 'expired';
            });
            
            // Methods
            const getPlayerUnits = (playerId) => {
                // Return only units that are not attached to another unit
                // (attached heroes will be shown nested with their parent)
                return units.value.filter(u => 
                    u.player_id === playerId && !u.attached_to_unit_id
                );
            };
            
            const getAttachedHeroes = (parentUnitId) => {
                return units.value.filter(u => u.attached_to_unit_id === parentUnitId);
            };
            
            const getArmyHealth = (playerId) => {
                const player = players.value.find(p => p.id === playerId);
                if (!player || player.starting_unit_count === 0) return 1;
                
                const currentUnits = units.value.filter(u => 
                    u.player_id === playerId && 
                    u.state?.deployment_status !== 'destroyed'
                ).length;
                
                return currentUnits / player.starting_unit_count;
            };
            
            const isMoraleThreshold = (playerId) => {
                return getArmyHealth(playerId) <= 0.5;
            };
            
            const getHealthBarClass = (health) => {
                if (health > 0.75) return 'bg-success';
                if (health > 0.5) return 'bg-warning';
                if (health > 0.25) return 'bg-orange-500';
                return 'bg-error';
            };
            
            const getPlayerVP = (playerId) => {
                const player = players.value.find(p => p.id === playerId);
                return player?.victory_points || 0;
            };
            
            const updateVP = async (playerId, delta) => {
                try {
                    const code = game.value?.code;
                    if (!code) return;
                    
                    const basePath = getBasePath();
                    const response = await fetch(`${basePath}/api/games/${code}/players/${playerId}/victory-points`, {
                        method: 'PATCH',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ delta }),
                    });
                    
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.detail || 'Failed to update VP');
                    }
                    
                    const updatedPlayer = await response.json();
                    
                    // Update local state
                    const index = players.value.findIndex(p => p.id === playerId);
                    if (index !== -1) {
                        players.value[index] = updatedPlayer;
                    }
                    
                    // Refresh game state to get updated events
                    await store.actions.fetchGame(code);
                    await store.actions.fetchEvents();
                } catch (error) {
                    alert('Failed to update VP: ' + error.message);
                }
            };
            
            const updateRound = async (delta) => {
                try {
                    const code = game.value?.code;
                    if (!code) return;
                    
                    const basePath = getBasePath();
                    const response = await fetch(`${basePath}/api/games/${code}/round`, {
                        method: 'PATCH',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ delta }),
                    });
                    
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.detail || 'Failed to update round');
                    }
                    
                    const updatedGame = await response.json();
                    
                    // Update local state
                    game.value.current_round = updatedGame.current_round;
                    
                    // Refresh game state to get updated events
                    await store.actions.fetchGame(code);
                    await store.actions.fetchEvents();
                } catch (error) {
                    alert('Failed to update round: ' + error.message);
                }
            };
            
            const getObjectiveClass = (obj) => {
                if (obj.status === 'contested') return 'border-dashed';
                return '';
            };
            
            const getObjectiveStyle = (obj) => {
                if (obj.status === 'neutral') {
                    return { backgroundColor: '#4b5563', borderColor: '#6b7280' };
                }
                if (obj.status === 'contested') {
                    return { backgroundColor: '#fbbf24', borderColor: '#f59e0b' };
                }
                const player = players.value.find(p => p.id === obj.controlled_by_id);
                return { 
                    backgroundColor: player?.color || '#4b5563',
                    borderColor: player?.color || '#6b7280',
                };
            };
            
            const cycleObjective = async (obj) => {
                const states = ['neutral', 'seized', 'contested'];
                const currentIndex = states.indexOf(obj.status);
                const nextIndex = (currentIndex + 1) % states.length;
                const nextStatus = states[nextIndex];
                
                // For seized, alternate between players
                let controlledById = null;
                if (nextStatus === 'seized') {
                    // If was neutral or contested, give to current player
                    // If was seized by other player, give to current player
                    controlledById = currentPlayerId.value;
                }
                
                await store.actions.updateObjective(obj.id, nextStatus, controlledById);
            };
            
            const updateUnit = async (unitId, changes) => {
                await store.actions.updateUnit(unitId, changes);
            };
            
            const importArmy = async () => {
                if (!armyForgeUrl.value) return;
                
                // Basic frontend validation
                const url = armyForgeUrl.value.trim();
                
                // Check for common console error patterns
                if (url.toLowerCase().includes('vue.global.js') || 
                    url.toLowerCase().includes('console') ||
                    url.toLowerCase().includes('error') ||
                    url.toLowerCase().includes('warn') ||
                    url.toLowerCase().includes('traceback') ||
                    url.toLowerCase().includes('exception') ||
                    url.length > 500) {
                    alert('Invalid input detected. Please paste the Army Forge share URL or list ID, not console output.\n\nExample: https://army-forge.onepagerules.com/share?id=XXXXX');
                    return;
                }
                
                isImporting.value = true;
                try {
                    // In solo mode, use selected player; otherwise use currentPlayerId
                    const playerId = game.value?.is_solo && selectedPlayerForUnits.value 
                        ? selectedPlayerForUnits.value 
                        : currentPlayerId.value;
                    
                    if (!playerId) {
                        alert('No player selected. Please select a player first.');
                        return;
                    }
                    
                    await store.actions.importArmy(GAME_CODE, url, playerId);
                    armyForgeUrl.value = '';
                } catch (error) {
                    console.error('Army import error:', error);
                    // Show error message - handle multi-line messages
                    const errorMsg = error.message || 'Unknown error occurred';
                    alert(errorMsg);
                } finally {
                    isImporting.value = false;
                }
            };
            
            const submitManualUnit = async () => {
                if (!manualUnitForm.name) {
                    alert('Unit name is required');
                    return;
                }
                
                isCreatingUnit.value = true;
                try {
                    // Parse JSON fields if provided
                    let loadout = null;
                    let rules = null;
                    
                    if (manualUnitForm.loadout_json && manualUnitForm.loadout_json.trim()) {
                        try {
                            loadout = JSON.parse(manualUnitForm.loadout_json.trim());
                        } catch (e) {
                            alert('Invalid loadout JSON: ' + e.message);
                            isCreatingUnit.value = false;
                            return;
                        }
                    }
                    
                    if (manualUnitForm.rules_json && manualUnitForm.rules_json.trim()) {
                        try {
                            rules = JSON.parse(manualUnitForm.rules_json.trim());
                        } catch (e) {
                            alert('Invalid rules JSON: ' + e.message);
                            isCreatingUnit.value = false;
                            return;
                        }
                    }
                    
                    // Build unit data
                    const unitData = {
                        name: manualUnitForm.name,
                        custom_name: manualUnitForm.custom_name || null,
                        quality: manualUnitForm.quality,
                        defense: manualUnitForm.defense,
                        size: manualUnitForm.size,
                        tough: manualUnitForm.tough,
                        cost: manualUnitForm.cost,
                        loadout: loadout,
                        rules: rules,
                        is_hero: manualUnitForm.is_hero,
                        is_caster: manualUnitForm.is_caster,
                        caster_level: manualUnitForm.is_caster ? manualUnitForm.caster_level : 0,
                        is_transport: manualUnitForm.is_transport,
                        transport_capacity: manualUnitForm.is_transport ? manualUnitForm.transport_capacity : 0,
                        has_ambush: manualUnitForm.has_ambush,
                        has_scout: manualUnitForm.has_scout,
                        attached_to_unit_id: manualUnitForm.attached_to_unit_id || null,
                    };
                    
                    // In solo mode, use selected player; otherwise use currentPlayerId
                    const playerId = game.value?.is_solo && selectedPlayerForUnits.value 
                        ? selectedPlayerForUnits.value 
                        : currentPlayerId.value;
                    
                    await store.actions.createUnitManually(GAME_CODE, unitData, playerId);
                    
                    // Reset form
                    manualUnitForm.name = '';
                    manualUnitForm.custom_name = '';
                    manualUnitForm.quality = 4;
                    manualUnitForm.defense = 4;
                    manualUnitForm.size = 1;
                    manualUnitForm.tough = 1;
                    manualUnitForm.cost = 0;
                    manualUnitForm.is_hero = false;
                    manualUnitForm.is_caster = false;
                    manualUnitForm.caster_level = 0;
                    manualUnitForm.is_transport = false;
                    manualUnitForm.transport_capacity = 0;
                    manualUnitForm.has_ambush = false;
                    manualUnitForm.has_scout = false;
                    manualUnitForm.attached_to_unit_id = null;
                    manualUnitForm.loadout_json = '';
                    manualUnitForm.rules_json = '';
                    
                    // Close modal
                    showManualUnitModal.value = false;
                } catch (error) {
                    alert('Failed to create unit: ' + error.message);
                } finally {
                    isCreatingUnit.value = false;
                }
            };
            
            const confirmClearUnits = async () => {
                if (!currentPlayerId.value) {
                    alert('No player selected');
                    return;
                }
                
                isClearingUnits.value = true;
                try {
                    await store.actions.clearAllUnits(GAME_CODE, currentPlayerId.value);
                    showClearUnitsModal.value = false;
                } catch (error) {
                    alert('Failed to clear units: ' + error.message);
                } finally {
                    isClearingUnits.value = false;
                }
            };
            
            const switchPlayer = (playerId) => {
                store.actions.switchPlayer(playerId);
            };
            
            const exportEventLog = async () => {
                try {
                    const response = await fetch(`/api/games/${GAME_CODE}/events/export`);
                    if (!response.ok) {
                        throw new Error('Failed to export event log');
                    }
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `game-${GAME_CODE}-events.md`;
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(a);
                } catch (error) {
                    alert('Failed to export event log: ' + error.message);
                }
            };
            
            const saveGame = async () => {
                if (!saveForm.saveName.trim()) {
                    alert('Please enter a save name');
                    return;
                }
                
                isSaving.value = true;
                try {
                    await store.actions.saveGame(
                        GAME_CODE,
                        saveForm.saveName.trim(),
                        saveForm.description.trim() || null
                    );
                    showSaveModal.value = false;
                    saveForm.saveName = '';
                    saveForm.description = '';
                    alert('Game saved successfully!');
                } catch (error) {
                    alert('Failed to save game: ' + error.message);
                } finally {
                    isSaving.value = false;
                }
            };
            
            const loadGame = async (saveId) => {
                isLoadingGame.value = true;
                try {
                    await store.actions.loadGame(GAME_CODE, saveId);
                    showLoadModal.value = false;
                    await store.actions.fetchGame(GAME_CODE);
                    alert('Game loaded successfully!');
                } catch (error) {
                    alert('Failed to load game: ' + error.message);
                } finally {
                    isLoadingGame.value = false;
                }
            };
            
            const loadSavesList = async () => {
                if (!showLoadModal.value) return;
                
                isLoadingSaves.value = true;
                try {
                    gameSaves.value = await store.actions.listSaves(GAME_CODE);
                } catch (error) {
                    alert('Failed to load saves: ' + error.message);
                } finally {
                    isLoadingSaves.value = false;
                }
            };
            
            const formatDate = (dateString) => {
                if (!dateString) return '';
                const date = new Date(dateString);
                return date.toLocaleString();
            };
            
            // Watch for load modal opening to fetch saves
            watch(
                showLoadModal,
                (isOpen) => {
                    if (isOpen) {
                        loadSavesList();
                    }
                }
            );
            
            // Watch currentPlayerId to sync selectedPlayerForUnits in solo mode
            watch(
                () => currentPlayerId.value,
                (newId) => {
                    if (game.value?.is_solo && newId) {
                        selectedPlayerForUnits.value = newId;
                    }
                }
            );
            
            // Initialize selectedPlayerForUnits when players are available
            watch(
                () => [players.value, game.value?.is_solo],
                ([playersList, isSolo]) => {
                    if (isSolo && playersList && playersList.length > 0) {
                        if (!selectedPlayerForUnits.value || !playersList.find(p => p.id === selectedPlayerForUnits.value)) {
                            selectedPlayerForUnits.value = currentPlayerId.value || playersList[0].id;
                        }
                    }
                },
                { immediate: true }
            );
            
            const createObjectives = async () => {
                try {
                    await store.actions.createObjectives(objectiveCount.value);
                    await store.actions.fetchGame(GAME_CODE);
                    await store.actions.fetchEvents();
                } catch (error) {
                    alert('Failed to create objectives: ' + error.message);
                }
            };
            
            const startGame = async () => {
                await store.actions.startGame();
            };
            
            const advanceRound = async () => {
                if (confirm('End current round and advance to the next?')) {
                    await store.actions.advanceRound();
                    // Fetch events for solo mode compatibility
                    await store.actions.fetchEvents();
                }
            };
            
            const endGame = async () => {
                if (confirm('End the game? This cannot be undone.')) {
                    const code = game.value?.code;
                    const basePath = getBasePath();
                    await fetch(`${basePath}/api/games/${code}/state`, {
                        method: 'PATCH',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ status: 'completed' }),
                    });
                    await store.actions.fetchGame(code);
                }
            };
            
            const formatTime = (timestamp) => {
                const date = new Date(timestamp);
                return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            };
            
            // Player selection state
            const showPlayerSelect = ref(false);
            const availablePlayers = ref([]);
            const allowNewPlayer = ref(false);
            const newPlayerName = ref('');
            const newPlayerColor = ref('#ef4444');
            const joinError = ref('');
            
            const selectPlayer = async (player) => {
                store.state.currentPlayerId = player.id;
                store.actions.savePlayerIdentity(GAME_CODE, player.id, player.name);
                showPlayerSelect.value = false;
                
                // Connect WebSocket with selected identity (skip for solo mode)
                if (!store.state.game?.is_solo) {
                    store.actions.connectWebSocket(GAME_CODE);
                }
            };
            
            const createNewPlayer = async () => {
                joinError.value = '';
                const name = newPlayerName.value.trim();
                if (!name) {
                    joinError.value = 'Please enter a name.';
                    return;
                }
                
                try {
                    const game = await store.actions.joinGame(
                        GAME_CODE,
                        name,
                        newPlayerColor.value || '#ef4444',
                    );
                    
                    // Persist identity
                    store.actions.savePlayerIdentity(GAME_CODE, game.your_player_id, name);
                    
                    // Refresh game state to reflect new player
                    await store.actions.fetchGame(GAME_CODE);
                    await store.actions.fetchEvents();
                    
                    // Set identity and close modal
                    store.state.currentPlayerId = game.your_player_id;
                    showPlayerSelect.value = false;
                    allowNewPlayer.value = false;
                    availablePlayers.value = [];
                    resetJoinState();
                    
                    // Connect WebSocket (skip for solo mode)
                    if (!store.state.game?.is_solo) {
                        store.actions.connectWebSocket(GAME_CODE);
                    }
                } catch (err) {
                    joinError.value = err.message || 'Failed to join game.';
                }
            };
            
            const resetJoinState = () => {
                joinError.value = '';
                newPlayerName.value = '';
                newPlayerColor.value = '#ef4444';
                allowNewPlayer.value = false;
            };
            
            // Lifecycle
            onMounted(async () => {
                const urlParams = new URLSearchParams(window.location.search);
                const queryPlayerId = urlParams.get('playerId');
                
                // Fetch game state first
                await store.actions.fetchGame(GAME_CODE);
                await store.actions.fetchEvents();
                
                // Check if game is expired and show modal
                if (store.state.game?.status === 'expired') {
                    showExpiredModal.value = true;
                }
                
                // Set up automatic event polling for solo games
                let eventPollInterval = null;
                if (store.state.game?.is_solo) {
                    eventPollInterval = setInterval(async () => {
                        await store.actions.fetchEvents();
                    }, 2000); // Poll every 2 seconds
                    
                    // Store interval ID for cleanup
                    window.eventPollInterval = eventPollInterval;
                }
                
                const playersList = (store.state.players || []).map(p => ({
                    ...p,
                    id: String(p.id),
                }));
                const connectedPlayers = playersList.filter(p => p.is_connected);
                const disconnectedPlayers = playersList.filter(p => !p.is_connected);
                const hasEmptySlot = playersList.length < 2;
                const currentId = store.state.currentPlayerId ? String(store.state.currentPlayerId) : null;
                
                // If we already have a current player in state and it exists, just connect
                if (currentId) {
                    const existing = playersList.find(p => p.id === currentId);
                    if (existing) {
                        showPlayerSelect.value = false;
                        allowNewPlayer.value = false;
                        store.state.currentPlayerId = existing.id;
                        store.actions.savePlayerIdentity(GAME_CODE, existing.id, existing.name);
                        // Only connect WebSocket if not solo mode
                        if (!store.state.game?.is_solo) {
                            store.actions.connectWebSocket(GAME_CODE);
                        }
                        return;
                    } else {
                        store.state.currentPlayerId = null;
                    }
                }
                
                // If playerId provided in URL and exists in game, use it (no prompt)
                if (queryPlayerId) {
                    const playerFromQuery = playersList.find(p => p.id === String(queryPlayerId));
                    if (playerFromQuery) {
                        store.state.currentPlayerId = queryPlayerId;
                        store.actions.savePlayerIdentity(GAME_CODE, queryPlayerId, playerFromQuery.name);
                        showPlayerSelect.value = false;
                        // Only connect WebSocket if not solo mode
                        if (!store.state.game?.is_solo) {
                            store.actions.connectWebSocket(GAME_CODE);
                        }
                        return;
                    }
                }
                
                // Try to restore player identity (localStorage)
                if (!store.state.currentPlayerId) {
                    const savedIdentity = store.actions.getSavedPlayerIdentity(GAME_CODE);
                    if (savedIdentity) {
                        const player = playersList.find(p => p.id === String(savedIdentity.playerId));
                        if (player) {
                            store.state.currentPlayerId = savedIdentity.playerId;
                            Debug.log('Restored player identity:', player.name);
                            // Only connect WebSocket if not solo mode
                        if (!store.state.game?.is_solo) {
                            store.actions.connectWebSocket(GAME_CODE);
                        }
                            return;
                        } else {
                            store.actions.clearPlayerIdentity(GAME_CODE);
                        }
                    }
                }
                
                // If no identity, try sessionStorage as fallback (only if player exists)
                if (!store.state.currentPlayerId) {
                    const sessionPlayerId = sessionStorage.getItem('herald_player_id');
                    if (sessionPlayerId) {
                        const player = playersList.find(p => p.id === String(sessionPlayerId));
                        if (player) {
                            store.state.currentPlayerId = sessionPlayerId;
                            // Save to localStorage for future
                            store.actions.savePlayerIdentity(GAME_CODE, sessionPlayerId, player.name);
                            // Only connect WebSocket if not solo mode
                        if (!store.state.game?.is_solo) {
                            store.actions.connectWebSocket(GAME_CODE);
                        }
                            return;
                        }
                    }
                }
                
                // No identity yet: determine prompt based on slot availability/connection
                resetJoinState();
                
                if (hasEmptySlot) {
                    // Host-only present: prompt to create Player 2
                    allowNewPlayer.value = true;
                    availablePlayers.value = [];
                    showPlayerSelect.value = true;
                    return;
                }
                
                if (connectedPlayers.length === 0) {
                    // No active users: select from previous players
                    allowNewPlayer.value = false;
                    availablePlayers.value = playersList;
                    showPlayerSelect.value = true;
                    return;
                }
                
                if (connectedPlayers.length === 1 && disconnectedPlayers.length >= 1) {
                    // One active (likely host), other disconnected: select disconnected player
                    allowNewPlayer.value = false;
                    availablePlayers.value = disconnectedPlayers;
                    showPlayerSelect.value = true;
                    return;
                }
                
                // If we somehow have an identity, allow proceeding even if both active
                if (currentId && playersList.some(p => p.id === currentId)) {
                    store.state.currentPlayerId = currentId;
                    store.actions.savePlayerIdentity(
                        GAME_CODE,
                        currentId,
                        playersList.find(p => p.id === currentId)?.name || 'Player'
                    );
                    showPlayerSelect.value = false;
                    allowNewPlayer.value = false;
                    joinError.value = '';
                    // Only connect WebSocket if not solo mode
                    if (!store.state.game?.is_solo) {
                        store.actions.connectWebSocket(GAME_CODE);
                    }
                    return;
                }
                
                // Both players active or unexpected state: block new joins
                allowNewPlayer.value = false;
                availablePlayers.value = [];
                showPlayerSelect.value = true;
                joinError.value = 'All player slots are currently active.';
            });
            
            // Hide modal automatically once identity is set and players are present
            watch(
                () => [currentPlayerId.value, players.value.length],
                ([pid, count]) => {
                    if (pid && count > 0) {
                        showPlayerSelect.value = false;
                        allowNewPlayer.value = false;
                        joinError.value = '';
                    }
                }
            );
            
            watch(
                () => store.state.currentPlayerId,
                (pid) => {
                    if (pid) {
                        showPlayerSelect.value = false;
                        allowNewPlayer.value = false;
                        joinError.value = '';
                    }
                }
            );
            
            // Also hide if we get a full state where our player exists
            watch(
                () => players.value.map(p => String(p.id)),
                () => {
                    const pid = store.state.currentPlayerId ? String(store.state.currentPlayerId) : null;
                    if (pid && players.value.some(p => String(p.id) === pid)) {
                        showPlayerSelect.value = false;
                        allowNewPlayer.value = false;
                        joinError.value = '';
                    }
                }
            );
            
            onUnmounted(() => {
                store.actions.disconnectWebSocket();
                // Clear event polling interval if it exists
                if (window.eventPollInterval) {
                    clearInterval(window.eventPollInterval);
                    window.eventPollInterval = null;
                }
            });
            
            return {
                // State
                game,
                players,
                units,
                objectives,
                events,
                isLoading,
                isConnected,
                error,
                currentPlayerId,
                isExpired,
                showExpiredModal,
                leftPlayer,
                rightPlayer,
                armyForgeUrl,
                isImporting,
                showManualUnitModal,
                isCreatingUnit,
                manualUnitForm,
                showClearUnitsModal,
                isClearingUnits,
                confirmClearUnits,
                showSaveModal,
                showLoadModal,
                isSaving,
                isLoadingGame,
                isLoadingSaves,
                gameSaves,
                saveForm,
                switchPlayer,
                saveGame,
                loadGame,
                formatDate,
                selectedPlayerForUnits,
                showPlayerSelect,
                availablePlayers,
                allowNewPlayer,
                newPlayerName,
                newPlayerColor,
                joinError,
                
                // Computed
                statusBadgeClass,
                hasUnits,
                
                // Methods
                selectPlayer,
                getPlayerUnits,
                getAttachedHeroes,
                getArmyHealth,
                submitManualUnit,
                isMoraleThreshold,
                getHealthBarClass,
                getPlayerVP,
                updateVP,
                updateRound,
                updateUnit,
                importArmy,
                startGame,
                advanceRound,
                endGame,
                formatTime,
                createNewPlayer,
                getBasePath,
            };
        },
    };
    
    const app = createApp(GameBoardApp);
    app.config.compilerOptions.delimiters = ['[[', ']]'];
    app.mount('#game-board');
});
</script>
{% endblock %}
